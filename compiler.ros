#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  ;;#+quicklisp(ql:quickload '() :silent t)
  )

(defpackage :ros.script.compiler.3748945022
  (:use :cl))
(in-package :ros.script.compiler.3748945022)


(defconstant +tk-num+ 256)
(defconstant +tk-eof+ 257)

(defun noop ())

(defmacro inc! (i)
  `(let ((j ,i))
     (incf ,i)
     j))

(defstruct token
  ty
  val
  str)

(defun new-token-op (c)
  (make-token :ty c :str c))

(defun new-token-num (s)
  (make-token :ty +tk-num+ :val (parse-integer s) :str s))

(defparameter *tokens* (make-array 100))

(defun tokenize (code)
  (let ((tok "") (lst ()))
    (loop
      :for c :across code
      :do (cond
            ((string= " " c) (noop))
            ((or (string= "+" c) (string= "-" c))
             (setf lst (cons (new-token-op c) (cons (new-token-num tok) lst)))
             (setf tok ""))
            ;; digit-char-p
            (t (setf tok (format nil "~a~a" tok c)))))
    (if (> (length tok) 0)
      (setf lst (cons (new-token-num tok) lst)))
    (setf lst (cons (new-token-op +tk-eof+) lst))
    (setf lst (reverse lst))
    (loop :for l :in lst
          :for i :from 0
          :do (setf (aref *tokens* i) l))))

(defparameter *pos* 0)

(defconstant +nd-num+ 256)

(defstruct node
  ty
  lhs
  rhs
  val)

(defun new-node (op lhs rhs)
  (make-node :ty op :lhs lhs :rhs rhs))

(defun new-node-num (val)
  (make-node :ty +nd-num+ :val val))

(defun exit-error (fmt &rest args)
  (apply #'format (cons t (cons fmt args)))
  (format t "~%")
  (abort))

(defun num ()
  (if (eql (token-ty (aref *tokens* *pos*)) +tk-num+)
    (let ((ret (new-node-num (token-val (aref *tokens* *pos*)))))
      (incf *pos*)
      ret)
    (exit-error "number expected, but got ~a" (token-str (aref *tokens* *pos*)))))

(defun expr ()
  (let ((lhs (num)) (op))
    (loop :do (progn
                (setf op (token-ty (aref *tokens* *pos*)))
                (if (and (not (eql op #\+)) (not (eql op #\-)))
                  (return)
                  (progn
                    (incf *pos*)
                    (setf lhs (new-node op lhs (num)))))))
    (if (not (eql (token-ty (aref *tokens* *pos*)) +tk-eof+))
      (exit-error "stray token: ~a" (token-str (aref *tokens* *pos*))))
    lhs))

;; Intermediate representation

(defconstant +ir-imm+ 0)
(defconstant +ir-mov+ 1)
(defconstant +ir-return+ 2)
(defconstant +ir-kill+ 3)
(defconstant +ir-nop+ 4)

(defstruct ir
  op
  lhs
  rhs)

(defun new-ir (op lhs rhs)
  (make-ir :op op :lhs lhs :rhs rhs))

(defparameter *ins* (make-array 100))
(defparameter *inp* 0)
(defparameter *regno* 0)

(defun gen-ir-sub (node)
  (if (eql (node-ty node) +nd-num+)
    (let ((r *regno*))
      (setf (aref *ins* *inp*) (new-ir +ir-imm+ r (node-val node)))
      (incf *inp*)
      (incf *regno*)
      r)
    (progn
      (assert (or (eql (node-ty node) #\+) (eql (node-ty node) #\-)))
      (let ((lhs (gen-ir-sub (node-lhs node))) (rhs (gen-ir-sub (node-rhs node))))
        (setf (aref *ins* (inc! *inp*)) (new-ir (node-ty node) lhs rhs))
        (setf (aref *ins* (inc! *inp*)) (new-ir +ir-kill+ rhs 0))
        lhs))))
(defun gen-ir (node)
  (let ((r (gen-ir-sub node)))
    (setf (aref *ins* (inc! *inp*)) (new-ir +ir-return+ r 0))))


(defparameter *regs* (make-array 8 :initial-contents
                                 '("rdi" "rsi" "r10" "r11" "r12" "r13" "r14" "r15")))
(defparameter *used* (make-array 8 :initial-element nil))

(defparameter *reg-map* (make-array 1000))

(defun alloc (ir-reg)
  (if (not (= (aref *reg-map* ir-reg) -1))
    (let ((r (aref *reg-map* ir-reg)))
      (assert (aref *used* r))
      r)
    (block exit
           (loop :for i :from 0 :below (length *regs*) :by 1
                 :do (progn
                       (if (not (aref *used* i))
                         (progn
                           (setf (aref *used* i) t)
                           (setf (aref *reg-map* ir-reg) i)
                           (return-from exit i)))))
           (exit-error "register exhausted"))))

(defun kill (r)
  (assert (aref *used* r))
  (setf (aref *used* r) nil))

(defun alloc-regs ()
  (loop :for i :from 0 :below *inp* :by 1
        :do (let* ((ir (aref *ins* i)) (op (ir-op ir)))
              (cond ((eql op +ir-imm+)
                     (setf (ir-lhs ir) (alloc (ir-lhs ir))))
                    ((or (eql op +ir-imm+) (eql op #\+) (eql op #\-))
                     (setf (ir-lhs ir) (alloc (ir-lhs ir)))
                     (setf (ir-rhs ir) (alloc (ir-rhs ir))))
                    ((eql op +ir-return+)
                     (kill (aref *reg-map* (ir-lhs ir))))
                    ((eql op +ir-kill+)
                     (kill (aref *reg-map* (ir-lhs ir)))
                     (setf (ir-op ir) +ir-nop+))
                    (t (assert (and 0 "unkonw operator")))))))

(defun gen-x86 ()
  (loop :for i :from 0 :below *inp* :by 1
        :do (let* ((ir (aref *ins* i)) (op (ir-op ir)))
              (cond ((eql op +ir-imm+)
                     (format t "  mov ~a, ~a~%" (aref *regs* (ir-lhs ir)) (ir-rhs ir)))
                    ((eql op +ir-mov+)
                     (format t "  mov ~a, ~a~%" (aref *regs* (ir-lhs ir)) (aref *regs* (ir-rhs ir))))
                    ((eql op +ir-return+)
                     (format t "  mov rax, ~a~%" (aref *regs* (ir-lhs ir)))
                     (format t "  ret~%"))
                    ((eql op #\+)
                     (format t "  add ~a, ~a~%" (aref *regs* (ir-lhs ir)) (aref *regs* (ir-rhs ir))))
                    ((eql op #\-)
                     (format t "  sub ~a, ~a~%" (aref *regs* (ir-lhs ir)) (aref *regs* (ir-rhs ir))))
                    ((= op +ir-nop+))
                    (t (assert (and 0 "unkonw operator")))))))


(defun main (&rest argv)
  (let ((node))
    (if (not (eq (length argv) 1))
      (format t "Usage: ros compiler.ros <code>~%")
      (progn
        (loop :for i :from 0 :below (length *reg-map*) :by 1
              :do (setf (aref *reg-map* i) -1))
        (tokenize (car argv))
        (setf node (expr))
        
        (gen-ir node)
        (alloc-regs)

        (format t ".intel_syntax noprefix~%")
        (format t ".global main~%")
        (format t "main:~%")
        (gen-x86)))))

;;; vim: set ft=lisp lisp:
