#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  ;;#+quicklisp(ql:quickload '() :silent t)
  )

(defpackage :ros.script.compiler.3748945022
  (:use :cl))
(in-package :ros.script.compiler.3748945022)

(defun noop ())

(defmacro inc! (i)
  `(let ((j ,i))
     (incf ,i)
     j))


;; Vector
(defun new-vec ()
  (make-array 16 :initial-element nil :fill-pointer 0 :adjustable t))

(defun vec-push (v elem)
  (vector-push-extend elem v))


;; Tokenizer
(defconstant +tk-num+ 256)
(defconstant +tk-eof+ 257)

;; Token type
(defstruct token
  ty
  val
  str)

;;(defun new-token-op (c)
;;  (make-token :ty c :str c))
;;
;;(defun new-token-num (s)
;;  (make-token :ty +tk-num+ :val (parse-integer s) :str s))
;;
(defparameter *tokens* (make-array 100))

(defun add-token (v ty input)
  (let ((tok (make-token :ty ty :str input)))
    (vec-push v tok)
    tok))

(defun tokenize (code)
  (let ((v (new-vec)) (tok ""))
    (loop
      :for c :across code
      :do (cond
            ((string= " " c) (noop))
            ((or (string= "+" c) (string= "-" c))
             (let ((tk (add-token v +tk-num+ tok)))
               (setf (token-val tk) (parse-integer tok)))
             (add-token v c c)
             (setf tok ""))
            ;; digit-char-p
            (t (setf tok (format nil "~a~a" tok c)))))
    (if (> (length tok) 0)
      (let ((tk (add-token v +tk-num+ tok)))
        (setf (token-val tk) (parse-integer tok))))
    (add-token v +tk-eof+ "")
    v))

(defparameter *pos* 0)

(defconstant +nd-num+ 256)

(defstruct node
  ty
  lhs
  rhs
  val)

(defun new-node (op lhs rhs)
  (make-node :ty op :lhs lhs :rhs rhs))

(defun new-node-num (val)
  (make-node :ty +nd-num+ :val val))

(defun exit-error (fmt &rest args)
  (apply #'format (cons t (cons fmt args)))
  (format t "~%")
  (abort))

(defun num ()
;;  (new-node-num 1))
  (if (eql (token-ty (aref *tokens* *pos*)) +tk-num+)
    (let ((ret (new-node-num (token-val (aref *tokens* *pos*)))))
      (incf *pos*)
      ret)
    (exit-error "number expected, but got ~a" (token-str (aref *tokens* *pos*)))))

(defun expr ()
  (let ((lhs (num)) (op))
    (loop :do (progn
                (setf op (token-ty (aref *tokens* *pos*)))
                (if (and (not (eql op #\+)) (not (eql op #\-)))
                  (return)
                  (progn
                    (incf *pos*)
                    (setf lhs (new-node op lhs (num)))))))
    (if (not (eql (token-ty (aref *tokens* *pos*)) +tk-eof+))
      (exit-error "stray token: ~a" (token-str (aref *tokens* *pos*))))
    lhs))

;; Intermediate representation

(defconstant +ir-imm+ 0)
(defconstant +ir-mov+ 1)
(defconstant +ir-return+ 2)
(defconstant +ir-kill+ 3)
(defconstant +ir-nop+ 4)

(defstruct ir
  op
  lhs
  rhs)

(defun new-ir (op lhs rhs)
  (make-ir :op op :lhs lhs :rhs rhs))

(defparameter *regno* 0)

(defun gen-ir-sub (v node)
  (if (eql +nd-num+ (node-ty node))
    (let ((r *regno*))
      (vec-push v (new-ir +ir-imm+ r (node-val node)))
      (incf *regno*)
      r)
    (progn
      (assert (or (eql (node-ty node) #\+) (eql (node-ty node) #\-)))
      (let ((lhs (gen-ir-sub v (node-lhs node))) (rhs (gen-ir-sub v (node-rhs node))))
        (vec-push v (new-ir (node-ty node) lhs rhs))
        (vec-push v (new-ir +ir-kill+ rhs 0))
        lhs))))

(defun gen-ir (node)
  (let* ((v (new-vec)) (r (gen-ir-sub v node)))
    (vec-push v (new-ir +ir-return+ r 0))
    v))


(defparameter *regs* (make-array 8 :initial-contents
                                 '("rdi" "rsi" "r10" "r11" "r12" "r13" "r14" "r15")))
(defparameter *used* (make-array (length *regs*) :initial-element nil))

(defparameter *reg-map* (make-array 0))

(defun alloc (ir-reg)
  (if (not (= (aref *reg-map* ir-reg) -1))
    (let ((r (aref *reg-map* ir-reg)))
      (assert (aref *used* r))
      r)
    (block exit
           (loop :for i :from 0 :below (length *regs*) :by 1
                 :do (progn
                       (if (not (aref *used* i))
                         (progn
                           (setf (aref *used* i) t)
                           (setf (aref *reg-map* ir-reg) i)
                           (return-from exit i)))))
           (exit-error "register exhausted"))))

(defun kill (r)
  (assert (aref *used* r))
  (setf (aref *used* r) nil))

(defun alloc-regs (irv)
  (setf *reg-map* (make-array (length irv)))
  (loop :for i :from 0 :below (length irv) :by 1
        :do (setf (aref *reg-map* i) -1))

  (loop :for i :from 0 :below (length irv) :by 1
        :do (let* ((ir (aref irv i)) (op (ir-op ir)))
              (cond ((eql op +ir-imm+)
                     (setf (ir-lhs ir) (alloc (ir-lhs ir))))
                    ((or (eql op +ir-imm+) (eql op #\+) (eql op #\-))
                     (setf (ir-lhs ir) (alloc (ir-lhs ir)))
                     (setf (ir-rhs ir) (alloc (ir-rhs ir))))
                    ((eql op +ir-return+)
                     (kill (aref *reg-map* (ir-lhs ir))))
                    ((eql op +ir-kill+)
                     (kill (aref *reg-map* (ir-lhs ir)))
                     (setf (ir-op ir) +ir-nop+))
                    (t (assert (and 0 "unkonw operator")))))))

(defun gen-x86 (irv)
  (loop :for i :from 0 :below (length irv) :by 1
        :do (let* ((ir (aref irv i)) (op (ir-op ir)))
              (cond ((eql op +ir-imm+)
                     (format t "  mov ~a, ~a~%" (aref *regs* (ir-lhs ir)) (ir-rhs ir)))
                    ((eql op +ir-mov+)
                     (format t "  mov ~a, ~a~%" (aref *regs* (ir-lhs ir)) (aref *regs* (ir-rhs ir))))
                    ((eql op +ir-return+)
                     (format t "  mov rax, ~a~%" (aref *regs* (ir-lhs ir)))
                     (format t "  ret~%"))
                    ((eql op #\+)
                     (format t "  add ~a, ~a~%" (aref *regs* (ir-lhs ir)) (aref *regs* (ir-rhs ir))))
                    ((eql op #\-)
                     (format t "  sub ~a, ~a~%" (aref *regs* (ir-lhs ir)) (aref *regs* (ir-rhs ir))))
                    ((= op +ir-nop+))
                    (t (assert (and 0 "unkonw operator")))))))


(defun main (&rest argv)
  (let ((node))
    (if (not (eq (length argv) 1))
      (format t "Usage: ros compiler.ros <code>~%")
      (progn
        (loop :for i :from 0 :below (length *reg-map*) :by 1
              :do (setf (aref *reg-map* i) -1))
        (setf *tokens* (tokenize (car argv)))
        (setf node (expr))

        (let ((irv (gen-ir node)))
          (alloc-regs irv)

          (format t ".intel_syntax noprefix~%")
          (format t ".global main~%")
          (format t "main:~%")
          (gen-x86 irv))))))

;;; vim: set ft=lisp lisp:
